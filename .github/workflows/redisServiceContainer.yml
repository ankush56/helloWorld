######################################################################
#You can use service containers to 
#connect databases, web services, memory caches, and other tools to your workflow.
#GitHub creates a fresh Docker container for each service configured in the workflow, and destroys the service container when the job completes. 
#Steps in a job can communicate with all service containers that are part of the same job.
# For example, your workflow might need to run integration tests that require access to a database and memory cache.
# You can use the services keyword to create service containers that are part of a job in your workflow. For more information, see jobs.<job_id>.services.

# Must run on Linux self hosted or ubuntu-latest on github hosted
#If your job runs in a Docker container, you do not need to map ports on the host or the service container. If your job runs directly on the runner machine,
#you'll need to map any required service container ports to ports on the host runner machine.
#######################################################################
name: Redis Service Containers

on:
  # Triggers the workflow on push or pull request events but only for the master branch
  push:
   branches: [ master ]
  pull_request:
   branches: [ master ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  container-job:
    runs-on: ubuntu-latest
    container: node:10.18-jessie
    services:
    # label to access service container
      redis:
        image: redis
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      # Downloads a copy of the code in your repository before running CI tests
      - name: Check out repository code
        uses: actions/checkout@v2

      - name: Install dependencies
        run: npm ci
      